options:
  # don't touch thanks
  skp: &f[&6Skript&e+&f]  
  skp.ver: 1.0.0
  # regex used to split error messages
  regex: \s(?=\(.+(\.sk), )

import:
  java.io.File
  java.util.Scanner
  java.io.FileInputStream
  ch.njol.skript.log.RetainingLogHandler
  ch.njol.skript.log.TimingLogHandler
  ch.njol.util.OpenCloseable
  ch.njol.skript.aliases.Aliases
  ch.njol.skript.SkriptConfig
  ch.njol.skript.Skript
  org.bukkit.Bukkit
  java.util.logging.Level

# override the /sk command
on command:
  if command is "sk" or "skript":
    cancel event
    make sender execute command "skriptplus %arguments ? ""%"

on tab complete:
  if event-string is "/sk", "/skp" or "/skriptplus":
    set tab completions of position 1 to "reload", "enable", "disable", "info", "addon", "analyse" and "dump"
    
    # /skp (enable|reload) ....
    if tab arg-1 = ("reload", "enable", "disable" or "analyse"):
      if tab arg-1 = ("reload" or "disable"): 
        set {_tabs::*} to (enabled scripts, "scripts", "all", "config", "aliases")
      else:
        set {_tabs::*} to (all scripts)
      set tab completions of position 2 to {_tabs::*}
      
    else if tab arg-1 = "addon":
      set tab completions of position 2 to ("download", "delete")
      set tab completions of position 3 to ...(skp_get_addon_properties()).stringPropertyNames()
     
command /skriptplus [<string>] [<string>] [<string>]:
  aliases: skp
  permission: skript.admin
  trigger:
    if arg-1 is "reload", "enable" or "disable":
      if arg-2 isn't set:
        send "{@skp} &fPlease define the script." to sender
        stop
      
      if arg-2 isn't ("aliases", "scripts", "config" or "all"):
        # The only workaround for parsing script names with space
        if arg-3 is set:
          set {_script} to "%arg-2% %arg-3%"
             
        # add the .sk suffix if there isn't one
        set {_script} to skp_fix_file_name({_script} ? arg-2)

        # newly created scripts won't work with the "script is disabled" condition 
        set {_script.file} to new File("./plugins/Skript/scripts/%{_script}%")
        if {_script.file}.exists() = false:
          send "{@skp} &fThis script doesn't exist." to sender
          stop
      else:
        set {_script} to arg-2
             
      if arg-1 is "reload":
        skp_parse_script(sender, {_script})
      
      else if arg-1 is "enable":
        skp_parse_script(sender, {_script})
        
      else if arg-1 is "disable":
        disable script {_script}
        send "{@skp} &fDisabled &e%{_script}%&f." to sender
    
    else if arg-1 is "info":
      skp_send_info_message(sender)
    
    else if arg-1 is "addon":
      if arg-2 is "delete":
        if arg-3 isn't set:
          send "&cPlease define the addon you want to delete." to sender
          stop
        else if plugin arg-3 isn't enabled:
          send "{@skp} &fAddon not found." to sender
          stop
        set {_file} to skp_get_file_of_plugin(arg-3)
        {_file}.delete()
        send "{@skp} &fDeleted &e%arg-3%&f. Please restart your server." to sender

      else if arg-2 is "download":
        if arg-3 isn't set:
          send "&cPlease define the addon name." to sender
          stop
        set {_properties} to skp_get_addon_properties()
        set {_repo} to try {_properties}.getProperty((lowercase arg-3))
        if {_repo} isn't set:
          send "{@skp} &fCouldn't find that addon in &eaddon.properties&f file." to sender
          stop
        skp send a "GET" request to "https://api.github.com/repos/%{_repo}%/releases/latest" and store it in {_response}
        set {_file.name} to skp_read_response({_response}, "github_file_name")
        set {_download.link} to skp_read_response({_response}, "github_download_link")
        send "{@skp} &fDownloading addon &e%arg-3%&f..." to sender
        skp download file from {_download.link} and store it inside "./plugins/%{_file.name}%"
        send "{@skp} &fDownloaded addon &e%arg-3%&f. Please restart your server." to sender
        
    else if arg-1 is "analyse":
      if arg-2 isn't set:
        send "{@skp} &fPlease define the script you want to analyse." to sender
        stop
      skp_analyse_script(sender, skp_fix_file_name(arg-2))
      
    else if arg-1 is "dump":
      skp_send_dump_link(sender)
    
    else: # invalid or no arguments
      skp_send_help_message(sender)

function skp_send_help_message(p: object):
  send "welcome to skript+" to {_p}

function skp_send_info_message(p: object):
  send "{@skp} Please wait..." to {_p}
  skp get the latest version of "skript" and store it in {_skript.ver}
  skp get the latest version of "skript-plus" and store it in {_skp.ver}
  skp check the updates for all addons and store it in {_addons::*}
  skp check the updates for all dependencies and store it in {_dependencies::*}
  
  if {_skript.ver} != skript version:
    set {_skript.ver} to "&c%skript version% &7-> &a%{_skript.ver}%"
  else:
    set {_skript.ver} to "&a%{_skript.ver}%"
    
  if {_skp.ver} != "{@skp.ver}":
    set {_skp.ver} to "&c{@skp.ver} &7-> &a%{_skp.ver}%"
  else:
    set {_skp.ver} to "&a{@skp.ver}"
       
  send "&7--------[ &6Skript&e+ &fInfo &7]--------" to {_p}
  send "Skript Version: %{_skript.ver}%" to {_p}
  send "Skript+ Version: %{_skp.ver}%" to {_p}
  send "" and {_addons::*} to {_p}
  send "" and {_dependencies::*} to {_p}

function skp_send_dump_link(p: object):
  set {_dump} to skp_gen_dump()
  skp send a "POST" request to "https://api.mclo.gs/1/log" with data "content=%{_dump}%" and store it in {_response}
  set {_link} to skp_read_response({_response}, "log_link")
  send "&aDump generated! %{_link}%" to {_p}
               
function skp_parse_script(p: object, s: string):
  set {_log.handler} to new RetainingLogHandler().start()
  set {_timing.log.handler} to new TimingLogHandler().start()
  
  if {_s} = "all" or "aliases":
    Aliases.clear()
    Aliases.load()
    add "aliases" to {_reloaded::*}

  if {_s} = "all" or "config":
    SkriptConfig.load()
    add "config" to {_reloaded::*}

  if {_s} = "all" or "scripts":
    set {_scripts::*} to skp_get_enabled_scripts()
    add "all scripts" to {_reloaded::*}
    
  # specific script
  else if {_s} != ("all", "scripts", "aliases" or "config"):
    set {_scripts::*} to (all scripts where [input starts with {_s}])
    set {_reloaded::*} to {_s}
  
  #loop {_scripts::*}:
  # disable script loop-value
        
  create new section and store it in {_section}:
    set {_open.closeable} to OpenCloseable.combine({_log.handler}, {_timing.log.handler})
    loop (alphabetically sorted {_scripts::*}):
      reload script loop-value
    set {_ms} to {_timing.log.handler}.getTimeTaken()
    return {_ms}
  run section {_section} sync and store the result in {_ms} and wait
         
  set {_err} to {_log.handler}.getNumErrors()
  if {_err} > 0:
    loop ...{_log.handler}.getErrors():
      set {_color} to "&e"
      if loop-value.getLevel() = Level.SEVERE:
        set {_color} to "&c"
            
      set {_message::*} to (regex loop-value.toString() split at "{@regex}")
      set {_file.name} to (1st element of ((2nd element of ({_message::2} split at "(")) split at ", "))
      set {_line.num} to (1st element of ((2nd element of ({_message::2} split at "line ")) split at ":")) parsed as number
      set {_message::1} to (join {_color} and {_message::1})
      set {_message::2} to (join "&7" and {_message::2})

      if {_line.num} != 0:
        set {_lines::*} to skp_map_file_to_list("./plugins/Skript/scripts/%{_file.name}%")
        set {_message::1.1} to "&7[%{_line.num} - 1%] &f%{_lines::%{_line.num} - 1%} ? ""%"
        set {_message::1.2} to "&7[%{_line.num}%] <##fa8c8c>%{_lines::%{_line.num}%} ? ""%"
        set {_message::1.3} to "&7[%{_line.num} + 1%] &f%{_lines::%{_line.num} + 1%} ? ""%"     
          
      send formatted {_message::*} to {_p}
                
  if {_err} = 1:
    set {_err} to "1 error"
  else:
    set {_err} to "%{_err}% errors"
                
  send "{@skp} &fReloaded &e%{_reloaded::*}% &fin &e%{_ms}%ms &fwith &e%{_err}%&f." to {_p}
   
function skp_fix_file_name(s: string) :: string:
  if {_s} ends with "/":
    return {_s} # it is a directory

  else if {_s} ends with ".sk":
    return {_s}
    
  return "%{_s}%.sk"

function skp_analyse_script(p: object, script: string):
  set {_file} to new File("./plugins/Skript/scripts/%{_script}%")
  if {_file}.exists() = false:
    send "{@skp} &fFile not found." to {_p}
    stop
  create new section with arguments variables {_script} and store it in {_section}:
    set {_result} to "! Warning !%nl%Parsing times may be inaccurate because Skript wasn't made to parse code line by line!%nl%Only use these parsing times as an estimate.%nl%Analysed by SkriptPlus%nl%%nl%"
    set {_lines::*} to skp_map_file_to_list("./plugins/Skript/scripts/%{_script}%")
    loop {_lines::*}:
      loop-value doesn't contain "##"
      set {_time} to skp_get_parse_time(loop-value)
      set {_result} to "%{_result}%(%{_time}%ms) %loop-value% %nl%"
    return {_result}
  run section {_section} async and store the result in {_result} and wait
  skp send a "POST" request to "https://api.mclo.gs/1/log" with data "content=%{_result}%" and store it in {_response}
  set {_link} to skp_read_response({_response}, "log_link")
  send formatted "{@skp} Analysed &e%{_script}%&f! View it <link:%{_link}%>&e&nhere&r&f!" to {_p}
