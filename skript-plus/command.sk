options:
  # don't touch thanks
  skp: &f[&6Skript&e+&f]&r  
  skp.ver: 1.0.0
  # regex used to split error messages
  regex: \s(?=\(.+(\.sk), )

import:
  java.io.File
  java.util.Scanner
  java.io.FileInputStream
  ch.njol.skript.log.RetainingLogHandler
  ch.njol.skript.log.TimingLogHandler
  ch.njol.util.OpenCloseable
  ch.njol.skript.aliases.Aliases
  ch.njol.skript.SkriptConfig
  ch.njol.skript.Skript
  org.bukkit.Bukkit
  java.util.logging.Level

# override the /sk command
on command:
  if command is "sk" or "skript":
    if sender has permission "skript.admin":
      cancel event
      make sender execute command "skriptplus %arguments if arguments is set, else ""%"

command /skriptplus [<string>] [<string>] [<string>]:
  aliases: skp
  permission: skript.admin
  trigger:
    if arg-1 is "reload", "enable" or "disable":
      # The only workaround for parsing script names with space
      if arg-3 is set:
        set {_script} to "%arg-2% %arg-3%"
      if arg-1 is "reload":
        if arg-2 isn't set:
          send "{@skp} &fPlease define what to reload." to sender
          stop
        skp_parse_script(sender, ({_script} ? arg-2))
      
      else if arg-1 is "enable":
        if arg-2 isn't set:
          send "{@skp} &fPlease define what to enable." to sender
          stop
        stop
        
      else if arg-1 is "disable":
        if arg-2 isn't set:
          send "{@skp} &fPlease define what to disable." to sender
          stop
        else if script arg-1 isn't loaded:
          send "{@skp} &fScript is already disabled or doesn't exist." to sender
          stop
          
        disable script "%arg-1%.sk"
        send "{@skp} &fDisabled &e%arg-1%.sk&f." to sender
    
    else if arg-1 is "info":
      skp_send_info_message(sender)
    
    else if arg-1 is "addon":
      if arg-2 is "delete":
        if arg-3 isn't set:
          send "&cPlease define the addon you want to delete." to sender
          stop
        else if plugin arg-3 isn't enabled:
          send "{@skp} &fAddon not found." to sender
          stop
        set {_file} to skp_get_file_of_plugin(arg-3)
        {_file}.delete()
        send "{@skp} &fDeleted &e%arg-3%&f. Please restart your server." to sender

      else if arg-2 is "download":
        if arg-3 isn't set:
          send "&cPlease define the addon name." to sender
          stop
        set {_properties} to skp_get_addon_properties()
        set {_repo} to try {_properties}.getProperty((lowercase arg-3))
        if {_repo} isn't set:
          send "{@skp} &fCouldn't find that addon in &eaddon.properties&f file." to sender
          stop
        skp send a "GET" request to "https://api.github.com/repos/%{_repo}%/releases/latest" and store it in {_response}
        set {_file.name} to skp_read_response({_response}, "github_file_name")
        set {_download.link} to skp_read_response({_response}, "github_download_link")
        send "{@skp} &fDownloading addon &e%arg-3%&f..." to sender
        skp download file from {_download.link} and store it inside "./plugins/%{_file.name}%"
        send "{@skp} &fDownloaded addon &e%arg-3%&f. Please restart your server." to sender
    
    else if arg-1 is "analyse":
      if arg-2 isn't set:
        send "{@skp} &fPlease define the script you want to analyse." to sender
        stop
      set {_fis} to new FileInputStream("./plugins/Skript/scripts/%arg-2%.sk")
      if {_fis} isn't set:
        send "{@skp} &fFile not found." to sender
        stop
      set {_scanner} to new Scanner({_fis})
      set {_result} to "! Warning !%nl%Parsing times may be inaccurate because Skript wasn't made to parse code line by line!%nl%Only use these parsing times as an estimate.%nl%Analysed by SkriptPlus%nl%%nl%"
      while {_scanner}.hasNextLine():
        set {_line} to {_scanner}.nextLine()
        {_line} doesn't match "[\s]+##"
        set {_time} to skp_get_parse_time({_line})
        set {_result} to "%{_result}%(%{_time}%ms) %{_line}% %nl%"
      skp send a "POST" request to "https://api.mclo.gs/1/log" with data "content=%{_result}%" and store it in {_response}
      set {_link} to skp_read_response({_response}, "log_link")
      send "{@skp} Analysed %arg-2%! %{_link}%" to sender
      
    else if arg-1 is "dump":
      skp_send_dump_link(sender)
    
    else: # When invalid or no arguments
      skp_send_help_message(sender)

on tab complete:
  if event-string starts with "sk", "skp" or "skriptplus":
    if tab arg-1 is not set:
      set tab completions of position 1 to "reload", "enable", "disable", "info", "addon", "analyse" or "dump"
    # /skp (enable|reload) ....
    else if tab arg-1 = "reload", "enable", "disable" or "analyse":
      set {_tabs::*} to enabled scripts if tab arg-1 = "reload" or "disable", else skp_get_all_script_files()
      set tab completions of position 2 to "config" and {_tabs::*}


function skp_send_help_message(p: object):
  send "Welcome to {@skp}" to {_p}

function skp_send_info_message(p: object):
  send "{@skp} Please wait..." to {_p}
  skp get the latest version of "skript" and store it in {_skript.ver}
  skp get the latest version of "skript-plus" and store it in {_skp.ver}
  skp check the updates for all addons and store it in {_addons::*}
  skp check the updates for all dependencies and store it in {_dependencies::*}
  
  if {_skript.ver} != skript version:
    set {_skript.ver} to "&c%skript version% &7-> &a%{_skript.ver}%"
  else:
    set {_skript.ver} to "&a%{_skript.ver}%"
    
  if {_skp.ver} != "{@skp.ver}":
    set {_skp.ver} to "&c{@skp.ver} &7-> &a%{_skp.ver}%"
  else:
    set {_skp.ver} to "&a{@skp.ver}"
       
  send "&7--------[ {@skp} &fInfo &7]--------" to {_p}
  send "Skript Version: %{_skript.ver}%" to {_p}
  send "Skript+ Version: %{_skp.ver}%" to {_p}
  send "" and {_addons::*} to {_p}
  send "" and {_dependencies::*} to {_p}

function skp_send_dump_link(p: object):
  set {_dump} to skp_gen_dump()
  skp send a "POST" request to "https://api.mclo.gs/1/log" with data "content=%{_dump}%" and store it in {_response}
  set {_link} to skp_read_response({_response}, "log_link")
  send "&aDump generated! %{_link}%" to {_p}

               
# TODO
# somehow fix it not working with scripts/folders that have spaces in them
# if you reload a directory, it wont loop through other directories inside the directory
function skp_parse_script(p: object, s: string):
  if {_s} = "all":
    set {_start.log.handler} to true
    set {_reload::aliases} to true
    set {_reload::config} to true
    set {_reload::script} to "all"
  
  else if {_s} = "aliases":
    set {_start.log.handler} to true
    set {_reload::aliases} to true

  else if {_s} = "config":
    set {_reload::config} to true

  else if {_s} = "scripts":
    set {_start.log.handler} to true
    set {_reload::script} to "all"
  
  # Finally, for getting specific script
  else:
    loop skp_get_all_script_files("file"):
      if first element of split (last element of split loop-value.getPath() at "plugins\Skript\scripts\") at ".sk" = first element of split {_s} at ".sk":
        set {_scripts::*} to last element of split loop-value.getPath() at "plugins\Skript\scripts\"
        set {_reload::script} to "single"
        stop loop

  # Start of reload
  if {_start.log.handler} = true:
    set {_log.handler} to new RetainingLogHandler().start()
    set {_timing.log.handler} to new TimingLogHandler().start()

  if {_reload::config} = true:
    SkriptConfig.load()
         
  if {_reload::aliases} = true:
    Aliases.clear()
    Aliases.load()
  
  # else if {_s} != "all", "aliases", "scripts" or "config":
  #   if {_s} ends with "/":
  #     set {_dir} to new File("./plugins/Skript/scripts/%{_s}%")
  #     set {_files::*} to ...{_dir}.listFiles()
  #     loop {_files::*}:
  #       add loop-value.getName() to {_scripts::*}
  #   else:
  #     set {_scripts::*} to {_s}

  if {_reload::script} is set:
    if {_reload::script} = "all":
      set {_scripts::*} to (alphabetically sorted skp_get_enabled_scripts())
      broadcast "DEBUG enabled scripts: %{_scripts::*}%"
      loop {_scripts::*}:
        disable script loop-value

    create new section and store it in {_section}:
      set {_open.closeable} to OpenCloseable.combine({_log.handler}, {_timing.log.handler})
      loop {_scripts::*}:
        enable script loop-value
    run section {_section} sync and wait
    
    if {_log.handler}.getNumErrors() > 0:
      loop ...{_log.handler}.getErrors():
        set {_color} to "&e"
        if loop-value.getLevel() = Level.SEVERE:
          set {_color} to "&c"
            
        set {_message::*} to (regex loop-value.toString() split at "{@regex}")
        set {_file.name} to (1st element of ((2nd element of ({_message::2} split at "(")) split at ", "))
        set {_line.num} to (1st element of ((2nd element of ({_message::2} split at "line ")) split at ":")) parsed as number
        set {_message::1} to (join {_color} and {_message::1})
        set {_message::2} to (join "&7" and {_message::2})

        set {_lines::*} to skp_map_file_to_list("./plugins/Skript/scripts/%{_file.name}%")
        set {_message::1.1} to "&7[%{_line.num} - 1%] &f%{_lines::%{_line.num} - 1%} ? ""%"
        set {_message::1.2} to "&7[%{_line.num}%] <##fa8c8c>%{_lines::%{_line.num}%} ? ""%"
        set {_message::1.3} to "&7[%{_line.num} + 1%] &f%{_lines::%{_line.num} + 1%} ? ""%"     
          
        send formatted {_message::*} to {_p}
    
    send "{@skp} &fParsed &e%size of {_scripts::*}% &escript%"" if size of {_scripts::*} = 1, else "s"% &fin &e%{_timing.log.handler}.getTimeTaken()%ms &fwith &e%{_log.handler}.getNumErrors()% error(s)&f." to {_p}
